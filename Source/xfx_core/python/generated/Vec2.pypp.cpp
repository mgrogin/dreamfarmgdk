// This file has been generated by Py++.

#include "xfx.h"
#include "boost/python.hpp"
#include "xfx_py_bindings.h"
#include "vec2.pypp.hpp"

namespace bp = boost::python;

void register_Vec2_class(){

    { //::xfx::Vec2
        typedef bp::class_< xfx::Vec2 > Vec2_exposer_t;
        Vec2_exposer_t Vec2_exposer = Vec2_exposer_t( "Vec2", bp::init< >() );
        bp::scope Vec2_scope( Vec2_exposer );
        Vec2_exposer.def( bp::init< float >(( bp::arg("v") )) );
        bp::implicitly_convertible< float, xfx::Vec2 >();
        Vec2_exposer.def( bp::init< xfx::Vec2 const & >(( bp::arg("v") )) );
        Vec2_exposer.def( bp::init< float, float >(( bp::arg("vx"), bp::arg("vy") )) );
        { //::xfx::Vec2::Clip
        
            typedef void ( *clip_function_type )( ::xfx::Vec2 & );
            
            Vec2_exposer.def( 
                "clip"
                , clip_function_type( &::xfx::Vec2::Clip )
                , ( bp::arg("v") ) );
        
        }
        { //::xfx::Vec2::Dot
        
            typedef float ( *dot_function_type )( ::xfx::Vec2 const &,::xfx::Vec2 const & );
            
            Vec2_exposer.def( 
                "dot"
                , dot_function_type( &::xfx::Vec2::Dot )
                , ( bp::arg("u"), bp::arg("v") ) );
        
        }
        { //::xfx::Vec2::Lerp
        
            typedef ::xfx::Vec2 ( *lerp_function_type )( ::xfx::Vec2 const &,::xfx::Vec2 const &,float const & );
            
            Vec2_exposer.def( 
                "lerp"
                , lerp_function_type( &::xfx::Vec2::Lerp )
                , ( bp::arg("u"), bp::arg("v"), bp::arg("t") ) );
        
        }
        { //::xfx::Vec2::Normalize
        
            typedef void ( ::xfx::Vec2::*normalize_function_type )(  ) ;
            
            Vec2_exposer.def( 
                "normalize"
                , normalize_function_type( &::xfx::Vec2::Normalize ) );
        
        }
        { //::xfx::Vec2::Rand
        
            typedef ::xfx::Vec2 ( *rand_function_type )(  );
            
            Vec2_exposer.def( 
                "rand"
                , rand_function_type( &::xfx::Vec2::Rand ) );
        
        }
        { //::xfx::Vec2::ToString
        
            typedef ::xfx::String ( ::xfx::Vec2::*__repr___function_type )(  ) const;
            
            Vec2_exposer.def( 
                "__repr__"
                , __repr___function_type( &::xfx::Vec2::ToString ) );
        
        }
        Vec2_exposer.def( bp::self *= bp::other< float >() );
        Vec2_exposer.def( bp::self *= bp::self );
        Vec2_exposer.def( bp::self += bp::self );
        Vec2_exposer.def( -bp::self );
        Vec2_exposer.def( bp::self -= bp::self );
        Vec2_exposer.def( bp::self /= bp::other< float >() );
        { //::xfx::Vec2::operator=
        
            typedef ::xfx::Vec2 & ( ::xfx::Vec2::*assign_function_type )( ::xfx::Vec2 const & ) ;
            
            Vec2_exposer.def( 
                "assign"
                , assign_function_type( &::xfx::Vec2::operator= )
                , ( bp::arg("v") )
                , bp::return_self< >() );
        
        }
        { //::xfx::Vec2::xy
        
            typedef void ( ::xfx::Vec2::*xy_function_type )( float,float ) ;
            
            Vec2_exposer.def( 
                "xy"
                , xy_function_type( &::xfx::Vec2::xy )
                , ( bp::arg("_x"), bp::arg("_y") ) );
        
        }
        Vec2_exposer.def_readwrite( "x", &xfx::Vec2::x );
        Vec2_exposer.def_readwrite( "y", &xfx::Vec2::y );
        Vec2_exposer.staticmethod( "clip" );
        Vec2_exposer.staticmethod( "dot" );
        Vec2_exposer.staticmethod( "lerp" );
        Vec2_exposer.staticmethod( "rand" );
        { //property "normalized"[fget=::xfx::Vec2::GetNormalized]
        
            typedef ::xfx::Vec2 ( ::xfx::Vec2::*fget )(  ) const;
            
            Vec2_exposer.add_property( 
                "normalized"
                , fget( &::xfx::Vec2::GetNormalized )
                , "get property, built on top of \"xfx::Vec2 xfx::Vec2::GetNormalized() const [member function]\"" );
        
        }
        { //property "len_sq"[fget=::xfx::Vec2::LenSq]
        
            typedef float ( ::xfx::Vec2::*fget )(  ) const;
            
            Vec2_exposer.add_property( 
                "len_sq"
                , fget( &::xfx::Vec2::LenSq )
                , "get property, built on top of \"float xfx::Vec2::LenSq() const [member function]\"" );
        
        }
        { //property "len"[fget=::xfx::Vec2::Len]
        
            typedef float ( ::xfx::Vec2::*fget )(  ) const;
            
            Vec2_exposer.add_property( 
                "len"
                , fget( &::xfx::Vec2::Len )
                , "get property, built on top of \"float xfx::Vec2::Len() const [member function]\"" );
        
        }
        Vec2_exposer.def( bp::self != bp::self );
        Vec2_exposer.def( bp::self * bp::other< float >() );
        Vec2_exposer.def( bp::other< float >() * bp::self );
        Vec2_exposer.def( bp::self + bp::self );
        Vec2_exposer.def( bp::self - bp::self );
        Vec2_exposer.def( bp::self / bp::other< float >() );
        Vec2_exposer.def( bp::self == bp::self );
        bp::register_ptr_to_python< boost::shared_ptr< xfx::Vec2 const > >( );
        bp::implicitly_convertible< boost::shared_ptr< xfx::Vec2 >, boost::shared_ptr< xfx::Vec2 const > >( );
    }

}
