// This file has been generated by Py++.

#include "xfx.h"
#include "boost/python.hpp"
#include "xfx_py_bindings.h"
#include "euler.pypp.hpp"

namespace bp = boost::python;

void register_Euler_class(){

    { //::xfx::Euler
        typedef bp::class_< xfx::Euler > Euler_exposer_t;
        Euler_exposer_t Euler_exposer = Euler_exposer_t( "Euler", bp::init< >() );
        bp::scope Euler_scope( Euler_exposer );
        Euler_exposer.def( bp::init< int >(( bp::arg("a") )) );
        bp::implicitly_convertible< int, xfx::Euler >();
        Euler_exposer.def( bp::init< int, int, int >(( bp::arg("_y"), bp::arg("_p"), bp::arg("_r") )) );
        { //::xfx::Euler::AngleDirections
        
            typedef void ( ::xfx::Euler::*angle_directions_function_type )( ::xfx::Vec3 &,::xfx::Vec3 &,::xfx::Vec3 & ) const;
            
            Euler_exposer.def( 
                "angle_directions"
                , angle_directions_function_type( &::xfx::Euler::AngleDirections )
                , ( bp::arg("f"), bp::arg("u"), bp::arg("r") ) );
        
        }
        { //::xfx::Euler::FromMat4
        
            typedef ::xfx::Euler & ( ::xfx::Euler::*from_mat4_function_type )( ::xfx::Mat4 const & ) ;
            
            Euler_exposer.def( 
                "from_mat4"
                , from_mat4_function_type( &::xfx::Euler::FromMat4 )
                , ( bp::arg("m") )
                , bp::return_self< >() );
        
        }
        { //::xfx::Euler::FromQuaternion
        
            typedef ::xfx::Euler & ( ::xfx::Euler::*from_quaternion_function_type )( ::xfx::Quaternion const & ) ;
            
            Euler_exposer.def( 
                "from_quaternion"
                , from_quaternion_function_type( &::xfx::Euler::FromQuaternion )
                , ( bp::arg("q") )
                , bp::return_self< >() );
        
        }
        { //::xfx::Euler::FromVec3
        
            typedef ::xfx::Euler & ( ::xfx::Euler::*from_vec3_function_type )( ::xfx::Vec3 const & ) ;
            
            Euler_exposer.def( 
                "from_vec3"
                , from_vec3_function_type( &::xfx::Euler::FromVec3 )
                , ( bp::arg("v") )
                , bp::return_self< >() );
        
        }
        { //::xfx::Euler::Lerp
        
            typedef ::xfx::Euler ( *lerp_function_type )( ::xfx::Euler const &,::xfx::Euler const &,float const & );
            
            Euler_exposer.def( 
                "lerp"
                , lerp_function_type( &::xfx::Euler::Lerp )
                , ( bp::arg("u"), bp::arg("v"), bp::arg("t") ) );
        
        }
        { //::xfx::Euler::Rotate
        
            typedef void ( ::xfx::Euler::*rotate_function_type )( ::xfx::Vec3 const &,int const & ) ;
            
            Euler_exposer.def( 
                "rotate"
                , rotate_function_type( &::xfx::Euler::Rotate )
                , ( bp::arg("axis"), bp::arg("ang") ) );
        
        }
        { //::xfx::Euler::ToString
        
            typedef ::xfx::String ( ::xfx::Euler::*__repr___function_type )(  ) const;
            
            Euler_exposer.def( 
                "__repr__"
                , __repr___function_type( &::xfx::Euler::ToString ) );
        
        }
        Euler_exposer.def( bp::self += bp::self );
        Euler_exposer.def( -bp::self );
        Euler_exposer.def( bp::self -= bp::self );
        { //::xfx::Euler::ypr
        
            typedef void ( ::xfx::Euler::*ypr_function_type )( int const &,int const &,int const & ) ;
            
            Euler_exposer.def( 
                "ypr"
                , ypr_function_type( &::xfx::Euler::ypr )
                , ( bp::arg("y"), bp::arg("p"), bp::arg("r") ) );
        
        }
        Euler_exposer.def_readwrite( "pitch", &xfx::Euler::pitch );
        Euler_exposer.def_readwrite( "roll", &xfx::Euler::roll );
        Euler_exposer.def_readwrite( "yaw", &xfx::Euler::yaw );
        Euler_exposer.staticmethod( "lerp" );
        { //property "to_mat4"[fget=::xfx::Euler::ToMat4]
        
            typedef ::xfx::Mat4 ( ::xfx::Euler::*fget )(  ) const;
            
            Euler_exposer.add_property( 
                "to_mat4"
                , fget( &::xfx::Euler::ToMat4 )
                , "get property, built on top of \"xfx::Mat4 xfx::Euler::ToMat4() const [member function]\"" );
        
        }
        { //property "to_vec3"[fget=::xfx::Euler::ToVec3]
        
            typedef ::xfx::Vec3 ( ::xfx::Euler::*fget )(  ) const;
            
            Euler_exposer.add_property( 
                "to_vec3"
                , fget( &::xfx::Euler::ToVec3 )
                , "get property, built on top of \"xfx::Vec3 xfx::Euler::ToVec3() const [member function]\"" );
        
        }
        { //property "to_quaternion"[fget=::xfx::Euler::ToQuaternion]
        
            typedef ::xfx::Quaternion ( ::xfx::Euler::*fget )(  ) const;
            
            Euler_exposer.add_property( 
                "to_quaternion"
                , fget( &::xfx::Euler::ToQuaternion )
                , "get property, built on top of \"xfx::Quaternion xfx::Euler::ToQuaternion() const [member function]\"" );
        
        }
        { //property "forward"[fget=::xfx::Euler::Forward]
        
            typedef ::xfx::Vec3 ( ::xfx::Euler::*fget )(  ) const;
            
            Euler_exposer.add_property( 
                "forward"
                , fget( &::xfx::Euler::Forward )
                , "get property, built on top of \"xfx::Vec3 xfx::Euler::Forward() const [member function]\"" );
        
        }
        { //property "up"[fget=::xfx::Euler::Up]
        
            typedef ::xfx::Vec3 ( ::xfx::Euler::*fget )(  ) const;
            
            Euler_exposer.add_property( 
                "up"
                , fget( &::xfx::Euler::Up )
                , "get property, built on top of \"xfx::Vec3 xfx::Euler::Up() const [member function]\"" );
        
        }
        { //property "right"[fget=::xfx::Euler::Right]
        
            typedef ::xfx::Vec3 ( ::xfx::Euler::*fget )(  ) const;
            
            Euler_exposer.add_property( 
                "right"
                , fget( &::xfx::Euler::Right )
                , "get property, built on top of \"xfx::Vec3 xfx::Euler::Right() const [member function]\"" );
        
        }
        Euler_exposer.def( bp::self != bp::self );
        Euler_exposer.def( bp::other< float >() * bp::self );
        Euler_exposer.def( bp::self * bp::other< float >() );
        Euler_exposer.def( bp::self + bp::self );
        Euler_exposer.def( bp::self - bp::self );
        Euler_exposer.def( bp::self == bp::self );
        bp::register_ptr_to_python< boost::shared_ptr< xfx::Euler const > >( );
        bp::implicitly_convertible< boost::shared_ptr< xfx::Euler >, boost::shared_ptr< xfx::Euler const > >( );
    }

}
